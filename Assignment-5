1. def twoSum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        if num in num_dict:
            return [num_dict[num], i]
        num_dict[target - num] = i
2.class ListNode:
    def _init_(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    while l1 or l2 or carry:
        x = l1.val if l1 else 0
        y = l2.val if l2 else 0
        sum = x + y + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    return dummy.next
3.def lengthOfLongestSubstring(s):
    if not s:
        return 0
    start = 0
    max_length = 0
    char_dict = {}
    for end in range(len(s)):
        if s[end] in char_dict:
            start = max(start, char_dict[s[end]] + 1)
        char_dict[s[end]] = end
        max_length = max(max_length, end - start + 1)
    return max_length
4. def findMedianSortedArrays(nums1, nums2):
    merged = sorted(nums1 + nums2)
    length = len(merged)
    if length % 2 == 0:
        return (merged[length // 2 - 1] + merged[length // 2]) / 2
    else:
        return merged[length // 2]
5.def longestPalindrome(s):
    if not s:
        return ""
    start = 0
    max_length = 0
    for i in range(len(s)):
        left, right = i, i
        while left >= 0 and right < len(s) and s[left] == s[right]:
            if right - left + 1 > max_length:
                start = left
                max_length = right - left + 1
            left -= 1
            right += 1
    return s[start:start + max_length]

6.def convert(s, numRows):
    if numRows == 1 or numRows >= len(s):
        return s
    result = [''] * numRows
    index, step = 0, 1
    for char in s:
        result[index] += char
        if index == 0:
            step = 1
        elif index == numRows - 1:
            step = -1
        index += step
    return ''.join(result)
7.def reverse(x):
    negative = False
    if x < 0:
        x, negative = -x, True
    result = 0
    while x:
        result = result * 10 + x % 10
        x //= 10
    if negative:
        result = -result
    if result < -2*31 or result > 2*31 - 1:
        return 0
    return result

8.def myAtoi(s):
    s = s.lstrip()
    if not s:
        return 0
    if s[0] in ['+', '-']:
        sign = 1 if s[0] == '+' else -1
        s = s[1:]
    else:
        sign = 1
    result = 0
    for char in s:
        if not char.isdigit():
            break
        result = result * 10 + int(char)
    result *= sign
    if result < -2**31:
        return -2**31
    elif result > 2**31 - 1:
        return 2**31 - 1
    return result

9. def isPalindrome(x):
    if x < 0:
        return False
    original = x
    reversed_num = 0
    while x:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    return original == reversed_num

10.def isMatch(s, p):
    if not p:
        return not s
    if p[0] == '*':
        return (isMatch(s, p[1:]) or (s and isMatch(s[1:], p)))
    return (s and s[0] == p[0] and isMatch(s[1:], p[1:]))
11.def maxArea(height):
   left, right = 0, len(height) - 1
   max_area = 0
   while left < right:
       area = (right - left) * min(height[left], height[right])
       max_area = max(max_area, area)
       if height[left] < height[right]:
           left += 1
       else:
           right -= 1
   return max_area
12.def intToRoman(num):
   roman = ''
   values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
   symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
   for value, symbol in zip(values, symbols):
       count = num // value
       roman += symbol * count
       num -= value * count
   return roman
13.def romanToInt(s):
   roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
   result = 0
   for i in range(len(s)):
       if i > 0 and roman[s[i]] > roman[s[i - 1]]:
           result += roman[s[i]] - 2 * roman[s[i - 1]]
       else:
           result += roman[s[i]]
   return result
14.def longestCommonPrefix(strs):
   if not strs:
       return ""
   prefix = strs[0]
   for s in strs[1:]:
       while not s.startswith(prefix):
           prefix = prefix[:-1]
   return prefix
15.def threeSum(nums):
   result = []
   nums.sort()
   for i in range(len(nums) - 2):
       if i > 0 and nums[i] == nums[i - 1]:
           continue
       left, right = i + 1, len(nums) - 1
       while left < right:
           sum = nums[i] + nums[left] + nums[right]
           if sum < 0:
               left += 1
           elif sum > 0:
               right -= 1
           else:
               result.append([nums[i], nums[left], nums[right]])
               while left < right and nums[left] == nums[left + 1]:
                   left += 1
               while left < right and nums[right] == nums[right - 1]:
                   right -= 1
               left += 1
               right -= 1
   return result
16.def threeSumClosest(nums, target):
   nums.sort()
   result = float('inf')
   for i in range(len(nums) - 2):
       left, right = i + 1, len(nums) - 1
       while left < right:
           sum = nums[i] + nums[left] + nums[right]
           if sum == target:
               return sum
           if abs(sum - target) < abs(result - target):
               result = sum
           if sum < target:
               left += 1
           else:
               right -= 1
   return result
17.def letterCombinations(digits):
   if not digits:
       return []
   phone = {'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z']}
   result = ['']
   for digit in digits:
       temp = []
       for res in result:
           for char in phone[digit]:
               temp.append(res + char)
       result = temp
   return result
18.def fourSum(nums, target):
   nums.sort()
   result = []
   for i in range(len(nums) - 3):
       if i > 0 and nums[i] == nums[i - 1]:
           continue
       for j in range(i + 1, len(nums) - 2):
           if j > i + 1 and nums[j] == nums[j - 1]:
               continue
           left, right = j + 1, len(nums) - 1
           while left < right:
               sum = nums[i] + nums[j] + nums[left] + nums[right]
               if sum < target:
                   left += 1
               elif sum > target:
                   right -= 1
               else:
                   result.append([nums[i], nums[j], nums[left], nums[right]])
                   while left < right and nums[left] == nums[left + 1]:
                       left += 1
                   while left < right and nums[right] == nums[right - 1]:
                       right -= 1
                   left += 1
                   right -= 1
   return result
19. def removeNthFromEnd(head, n):
   dummy = ListNode(0)
   dummy.next = head
   first = dummy
   second = dummy
   for _ in range(n + 1):
       first = first.next
   while first:
       first = first.next
       second = second.next
   second.next = second.next.next
   return dummy.next

20.def isValid(s):
   stack = []
   for char in s:
       if char in ['(', '{', '[']:
           stack.append(char)
       elif char in [')', '}', ']']:
           if not stack:
               return False
           top = stack.pop()
           if (top == '(' and char != ')') or (top == '{' and char != '}') or (top == '[' and char != ']'):
               return False
   return not stack
